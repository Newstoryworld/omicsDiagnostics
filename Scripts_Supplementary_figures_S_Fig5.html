<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="scheller, loipfinger" />

<meta name="date" content="2021-02-01" />

<title>PROTRIDER comparison to limma-based approach</title>

<script src="libR/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libR/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="libR/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libR/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libR/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="libR/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="libR/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="libR/tocify-1.9.1/jquery.tocify.js"></script>
<script src="libR/navigation-1.1/tabsets.js"></script>
<script src="libR/navigation-1.1/codefolding.js"></script>
<script src="libR/navigation-1.1/sourceembed.js"></script>
<link href="libR/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="libR/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
#rmd-source-code {
  display: none;
}
</style>

<link rel="stylesheet" href="lib/add_content_table.css" type="text/css" />
<link rel="stylesheet" href="lib/leo_style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="fluid-row" id="header">

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">PROTRIDER comparison to limma-based approach</h1>
<h4 class="author">scheller, loipfinger</h4>
<h4 class="date">2021-02-01</h4>

</div>


<pre class="r"><code>############################################
### plot limma - protrider benchmark

library(plyr)
library(dplyr)
library(data.table)
library(ggplot2)
library(ggpubr)

############################################
### read in protrider results
protrider_filename &lt;- snakemake@input$protrider_results
protrider_pval_list &lt;- as.data.table(readRDS(protrider_filename))
protrider_pval_list$sample_prot = paste0(protrider_pval_list$SAMPLE_ID,&quot;_&quot;, protrider_pval_list$geneID)

### read in limma results
limma_filename &lt;- snakemake@input$limma_results
limma_pval_list &lt;- as.data.table(readRDS(limma_filename))
limma_pval_list$sample_prot = paste0(limma_pval_list$SAMPLE_ID,&quot;_&quot;,limma_pval_list$geneID)

### keep only samples in both analyses, only if all whole limma list is considered
only_identical_samples &lt;- intersect(limma_pval_list$sample_prot, protrider_pval_list$sample_prot)
pval_ae_pre &lt;- subset(protrider_pval_list, sample_prot %in% only_identical_samples)
pval_limma_pre &lt;- subset(limma_pval_list, sample_prot %in% only_identical_samples)


############################################
### get sample annotation
sa_prot &lt;- fread(snakemake@input$sample_annotation)
sa_prot &lt;- sa_prot[USE_FOR_PROTEOMICS_PAPER == T]
sa_prot$KNOWN_MUTATION &lt;- toupper(sa_prot$KNOWN_MUTATION)
etp_m &lt;- sa_prot[, c(&#39;SAMPLE_ID&#39;, &#39;KNOWN_MUTATION&#39;,&#39;CATEGORY&#39;)]

# sa = subset(etp_m, CATEGORY==&quot;I&quot;)[,1:2]   ### for only confirmed ones
# sa = subset(etp_m, CATEGORY %in% c(&quot;I&quot;, &quot;IIa&quot;, &quot;III&quot;))[,1:2]   ### for only confirmed ones
sa = subset(etp_m, CATEGORY %in% c(&quot;I&quot;, &quot;IIa&quot;))[,1:2] ### only cases with previous candidate
sa$confirmed_out = !is.na(sa$KNOWN_MUTATION)
sa$sample_prot = paste0(sa$SAMPLE_ID,&quot;_&quot;,sa$KNOWN_MUTATION)

### merge known mutation to result lists
pval_ae_solved = join(pval_ae_pre,sa)
pval_ae_solved[is.na(confirmed_out), confirmed_out:=FALSE]
pval_ae_solved = pval_ae_solved[order(pval_ae_solved$PROTEIN_PVALUE),]
pval_ae_solved[, num_out_called:=cumsum(confirmed_out)]

pval_limma_solved = join(pval_limma_pre,sa)
pval_limma_solved$confirmed_out[is.na(pval_limma_solved$confirmed_out)] = FALSE
pval_limma_solved = pval_limma_solved[order(pval_limma_solved$PROTEIN_PVALUE),]
pval_limma_solved$num_out_called = cumsum(pval_limma_solved$confirmed_out)


############################################
### plotting
padj_cutoff = 0.1 #0.05 
ae_plot = subset(pval_ae_solved, PROTEIN_PADJ &lt;= padj_cutoff)
ae_plot$pvalue = log10(ae_plot$PROTEIN_PVALUE)
limma_plot = subset(pval_limma_solved, PROTEIN_PADJ &lt;= padj_cutoff)
limma_plot$pvalue = log10(limma_plot$PROTEIN_PVALUE)

# # Recall plot from Stefan L.
# plot(1:nrow(ae_plot),ae_plot$num_out_called, &#39;l&#39;,  lwd=2,
#      col=&#39;orange&#39;, xlim=c(0,nrow(limma_plot)),
#      ylim=c(0,max(max(ae_plot$num_out_called), max(limma_plot$num_out_called)) +2),
#      ylab=&#39;recall (#detected confirmed cases)&#39;, xlab=&quot;p value rank&quot;, main=paste0(&#39;adj_pval: &#39;,padj_cutoff,&#39; outlier called&#39;) )
# lines(1:nrow(limma_plot),limma_plot$num_out_called, col=&#39;blue&#39;, lwd=2)
# legend(&#39;bottomright&#39;,
#        legend=c(paste0(&#39;PROTRIDER [&#39;,max(ae_plot$num_out_called), &#39; in &#39;,which.max(ae_plot$num_out_called),&#39; / &#39; ,nrow(ae_plot),&#39;]&#39;) ,
#                 paste0(&#39;limma [&#39;,max(limma_plot$num_out_called), &#39; in &#39;,which.max(limma_plot$num_out_called),&#39; / &#39; ,nrow(limma_plot),&#39;]&#39;) ),
#        col=c(&#39;orange&#39;,&#39;blue&#39;), lty=1, lwd=10, title=&quot;method [confirmed cases]&quot;)

### same plot but as ggplot
ae_plot[, rank:=frank(PROTEIN_PVALUE, ties.method=&quot;min&quot;)]
ae_plot[, total:=.N]
ae_plot[, method:=&quot;PROTRIDER&quot;]
limma_plot[, rank:=frank(PROTEIN_PVALUE, ties.method=&quot;min&quot;)]
limma_plot[, total:=.N]
limma_plot[, method:=&quot;limma-based approach&quot;]

ae_limma_plot &lt;- rbind(ae_plot[,.(pvalue, num_out_called, rank, total, method)], 
                       limma_plot[,.(pvalue, num_out_called, rank, total, method)])
g &lt;- ggplot(ae_limma_plot, aes(x=rank, y=num_out_called, col=method)) +
    geom_line() +
    scale_y_continuous(limits=c(0, nrow(sa)), breaks=seq(0, nrow(sa), by=10),
                       minor_breaks=seq(0, nrow(sa)-5, by=10)+5) +
    xlab(&quot;p value rank&quot;) + ylab(&quot;recall (#detected confirmed cases)&quot;) + 
    ggtitle(paste0(&quot;adj_pval &lt;= &quot;, padj_cutoff)) +
    theme_bw() +
    theme(text=element_text(size=14), title=element_text(size=14),
          legend.title=element_blank(), legend.position=&quot;bottom&quot;,  # c(0.8, 0.15)
          plot.title = element_text(hjust = 0.5), legend.text=element_text(size=14))
# g

#### precision recall plot
ae_plot[, `:=`(precision=num_out_called/rank, recall=num_out_called/nrow(sa))]
limma_plot[, `:=`(precision=num_out_called/rank, recall=num_out_called/nrow(sa))]

plot_dt &lt;- rbind(ae_plot[,.(precision, recall, method)], limma_plot[,.(precision, recall, method)])


g_pr &lt;- ggplot(plot_dt, aes(x=recall, y=precision, col=method)) + geom_line() + 
    scale_x_continuous(limits=c(0,1)) + scale_y_continuous(limits=c(0,0.55)) +
    theme_bw() +
    theme(text=element_text(size=14), title=element_text(size=14),
          legend.position=c(0.8, 0.85))
# g_pr


### nominal p value cutoff
pval_cutoff = 0.05#0.1#0.05 #0.05 #1 #0.5#1# 0.05
ae_plot = subset(pval_ae_solved, PROTEIN_PVALUE &lt;= pval_cutoff)
ae_plot$pvalue = log10(ae_plot$PROTEIN_PVALUE)
limma_plot = subset(pval_limma_solved, PROTEIN_PVALUE &lt;= pval_cutoff)
limma_plot$pvalue = log10(limma_plot$PROTEIN_PVALUE)

ae_plot[, rank:=frank(PROTEIN_PVALUE, ties.method=&quot;min&quot;)]
ae_plot[, total:=.N]
ae_plot[, method:=&quot;PROTRIDER&quot;]
limma_plot[, rank:=frank(PROTEIN_PVALUE, ties.method=&quot;min&quot;)]
limma_plot[, total:=.N]
limma_plot[, method:=&quot;limma-based approach&quot;]

ae_limma_plot &lt;- rbind(ae_plot[,.(pvalue, num_out_called, rank, total, method)], 
                       limma_plot[,.(pvalue, num_out_called, rank, total, method)])
g_nominal &lt;- ggplot(ae_limma_plot, aes(x=rank, y=num_out_called, col=method)) +
    geom_line() +
    scale_y_continuous(limits=c(0, nrow(sa)), breaks=seq(0, nrow(sa), by=10),
                       minor_breaks=seq(0, nrow(sa)-5, by=10)+5) +
    xlab(&quot;p value rank&quot;) + ylab(&quot;recall (#detected confirmed cases)&quot;) + 
    ggtitle(paste0(&quot;nominal pvalue &lt;= &quot;, pval_cutoff)) +
    theme_bw() +
    theme(text=element_text(size=14), title=element_text(size=14), 
          legend.title=element_blank(), legend.position=&quot;bottom&quot;,
          plot.title=element_text(hjust = 0.5), legend.text=element_text(size=14))
# g_nominal

### combine into one Figure: panel a) recall for pvals with padj &lt; 0.1; panel b) recall for all nominal pval &lt; 0.05
g_fig &lt;- ggarrange(g, g_nominal, ncol=2, common.legend=TRUE, legend=&quot;bottom&quot;, labels=letters[1:2])
common_title &lt;- paste0(&quot;Recall of cases with pathogenic variants and validated VUS (n=&quot;, nrow(sa), &quot;)&quot;)
g_fig &lt;- annotate_figure(g_fig, top = text_grob(common_title, face = &quot;bold&quot;, size = 16))
g_fig</code></pre>
<p><img src="Scripts_Supplementary_figures_S_Fig5_files/figure-html/unnamed-chunk-1-1.png" width="672" /></p>
<pre class="r"><code>figure_file &lt;- snakemake@output$fig
ggsave(figure_file, g_fig, width=15, height=5)
# saveRDS(list(&quot;g_padj&quot;=g, &quot;g_nominal&quot;=g_nominal), file.path(dirname(figure_file), &quot;protrider_limma_figS5.rds&quot;))



#### precision recall plot (nominal pvalue cutoff)
ae_plot[, `:=`(precision=num_out_called/rank, recall=num_out_called/nrow(sa))]
limma_plot[, `:=`(precision=num_out_called/rank, recall=num_out_called/nrow(sa))]

plot_dt &lt;- rbind(ae_plot[,.(precision, recall, method)], limma_plot[,.(precision, recall, method)])


g_pr_nom &lt;- ggplot(plot_dt, aes(x=recall, y=precision, col=method)) + geom_line() + 
    scale_x_continuous(limits=c(0,1)) + scale_y_continuous(limits=c(0,0.55)) +
    theme_bw() +
    theme(text=element_text(size=14), title=element_text(size=14), 
          legend.title=element_blank(), legend.position=&quot;bottom&quot;,
          plot.title=element_text(hjust = 0.5), legend.text=element_text(size=14))
# g_pr_nom

# TODO only one plot needed, add the different pvalue cutoffs as shapes
g_pr_fig &lt;- ggarrange(g_pr, g_pr_nom, ncol=2, common.legend=TRUE, legend=&quot;bottom&quot;, labels=letters[1:2])
pr_common_title &lt;- paste0(&quot;Precision-recall curve for cases with pathogenic variants and validated VUS (n=&quot;, nrow(sa), &quot;)&quot;)
g_pr_fig &lt;- annotate_figure(g_pr_fig, top = text_grob(pr_common_title, face = &quot;bold&quot;, size = 16))
g_pr_fig</code></pre>
<p><img src="Scripts_Supplementary_figures_S_Fig5_files/figure-html/unnamed-chunk-1-2.png" width="672" /></p>
<pre class="r"><code>#### plot with both pvalue and z-score cutoffs
pval_cutoff &lt;- 0.05 
zscore_cutoff &lt;-  2
ae_plot_pval &lt;- subset(pval_ae_solved, PROTEIN_PVALUE &lt;= pval_cutoff)
ae_plot_pval$score &lt;- log10(ae_plot_pval$PROTEIN_PVALUE)
ae_plot_pval[,method:=&quot;PROTRIDER&quot;]
ae_plot_pval[,rankedBy:=&quot;p value&quot;]
ae_plot_z &lt;- subset(pval_ae_solved, abs(PROTEIN_ZSCORE) &gt;= zscore_cutoff)
ae_plot_z$score &lt;- -abs(ae_plot_z$PROTEIN_ZSCORE)
ae_plot_z = ae_plot_z[order(-abs(ae_plot_z$PROTEIN_ZSCORE)),]
ae_plot_z[, num_out_called:=cumsum(confirmed_out)]
ae_plot_z[,method:=&quot;PROTRIDER&quot;]
ae_plot_z[,rankedBy:=&quot;|z score|&quot;]
limma_plot_pval &lt;- subset(pval_limma_solved, PROTEIN_PVALUE &lt;= pval_cutoff)
limma_plot_pval$score &lt;- log10(limma_plot_pval$PROTEIN_PVALUE)
limma_plot_pval[,method:=&quot;limma-based approach&quot;]
limma_plot_pval[,rankedBy:=&quot;p value&quot;]
limma_plot_z &lt;- subset(pval_limma_solved, abs(PROTEIN_ZSCORE) &gt;= zscore_cutoff)
limma_plot_z$score &lt;- -abs(limma_plot_z$PROTEIN_ZSCORE)
limma_plot_z = limma_plot_z[order(-abs(limma_plot_z$PROTEIN_ZSCORE)),]
limma_plot_z[, num_out_called:=cumsum(confirmed_out)]
limma_plot_z[,method:=&quot;limma-based approach&quot;]
limma_plot_z[,rankedBy:=&quot;|z score|&quot;]

plot_dt &lt;- rbind(ae_plot_pval[,.(score, num_out_called, method, rankedBy)], 
                 ae_plot_z[,.(score, num_out_called, method, rankedBy)], 
                 limma_plot_pval[,.(score, num_out_called, method, rankedBy)], 
                 limma_plot_z[,.(score, num_out_called, method, rankedBy)])

plot_dt[, rank:=frank(score, ties.method=&quot;min&quot;), by=&quot;method,rankedBy&quot;]
plot_dt[, total:=.N, by=&quot;method,rankedBy&quot;]
plot_dt</code></pre>
<pre><code>## # A tibble: 201,913 x 6
##     score num_out_called method    rankedBy  rank total
##     &lt;dbl&gt;          &lt;int&gt; &lt;chr&gt;     &lt;chr&gt;    &lt;int&gt; &lt;int&gt;
##  1 -Inf                0 PROTRIDER p value      1 52508
##  2 -Inf                0 PROTRIDER p value      1 52508
##  3 -Inf                0 PROTRIDER p value      1 52508
##  4 -Inf                0 PROTRIDER p value      1 52508
##  5 -Inf                0 PROTRIDER p value      1 52508
##  6  -23.0              0 PROTRIDER p value      6 52508
##  7  -21.6              1 PROTRIDER p value      7 52508
##  8  -21.2              1 PROTRIDER p value      8 52508
##  9  -19.5              1 PROTRIDER p value      9 52508
## 10  -19.4              1 PROTRIDER p value     10 52508
## # … with 201,903 more rows</code></pre>
<pre class="r"><code>plot_dt[,rankedBy:=factor(rankedBy, levels=c(&quot;p value&quot;, &quot;|z score|&quot;))]

# additional fig: recall for all nominal pval &lt; 0.05 + |z-score| &gt; 2
log &lt;- FALSE
# log &lt;- TRUE
g_z &lt;- ggplot(plot_dt, aes(x=rank, y=num_out_called, col=method, linetype=rankedBy)) +
    geom_line() +
    scale_y_continuous(limits=c(0, nrow(sa)), breaks=seq(0, nrow(sa), by=10),
                       minor_breaks=seq(0, nrow(sa)-5, by=10)+5) +
    xlab(&quot;rank&quot;) + ylab(&quot;recall (#detected confirmed cases)&quot;) + 
    ggtitle(paste0(&quot;Recall of cases with pathogenic variants and validated VUS (n=&quot;, nrow(sa), &quot;)&quot;)) +
    theme_bw() +
    theme(text=element_text(size=14), title=element_text(size=14), 
          legend.position=&quot;bottom&quot;, legend.box=&quot;horizontal&quot;, legend.direction=&quot;vertical&quot;,
          plot.title=element_text(hjust = 0.5), legend.text=element_text(size=14)) +
    guides(color = guide_legend(title.position=&quot;left&quot;, order=1, title.theme=element_blank()),
           linetype=guide_legend(&quot;ranked by:&quot;, title.position=&quot;left&quot;, order=2))
if(log) g_z &lt;- g_z + scale_x_log10()
g_z</code></pre>
<p><img src="Scripts_Supplementary_figures_S_Fig5_files/figure-html/unnamed-chunk-1-3.png" width="672" /></p>
<pre class="r"><code>#### PROTRIDER global qq-plot
# code slightly adjusted from https://github.com/gagneurlab/OUTRIDER-analysis/blob/master/Scripts/PaperPlots/Figure3_global_qq_res.R 
getQQPlottingData &lt;- function(pval_list, method_name, conf.alpha=0.05){
    qqPlotDT &lt;- data.table(observedPvalue=pval_list[,PROTEIN_PVALUE],
                           aberrant=pval_list[,PROTEIN_outlier],
                           Method=method_name)
    qqPlotDT &lt;- qqPlotDT[order(observedPvalue)]
    
    qqPlotDT[,expectedPvalue:= ppoints(observedPvalue), by=Method]
    
    # set confidence
    qqPlotDT[,nlupper:=-log10(qbeta(  conf.alpha/2, 1:.N, .N:1)), by=Method]
    qqPlotDT[,nllower:=-log10(qbeta(1-conf.alpha/2, 1:.N, .N:1)), by=Method]
    
    ## sample to avoid plotting problems.
    qqPlotDTSampled &lt;- qqPlotDT[
        observedPvalue &lt;  1E-3 |
            observedPvalue &lt;  1E-2 &amp; sample(c(TRUE, FALSE), nrow(qqPlotDT), prob = c(0.1,  0.9),  replace = TRUE)|
            observedPvalue &gt;= 1E-2 &amp; sample(c(TRUE, FALSE), nrow(qqPlotDT), prob = c(0.01, 0.99), replace = TRUE)]
    qqPlotDTSampled[,neglog10expectedPvalue := -log10(expectedPvalue)]
    qqPlotDTSampled[,neglog10observedPvalue := -log10(observedPvalue)]
    
    return(qqPlotDTSampled)
}

zoomtheme &lt;- theme(legend.position=&quot;none&quot;, axis.title.x=element_blank(),
                   axis.title.y=element_blank(), title = element_blank(),
                   panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
                   panel.background = element_rect(color=&#39;white&#39;, fill=&quot;white&quot;),
                   plot.background = element_rect(color=&#39;white&#39;, fill = &quot;white&quot;),
                   plot.margin = unit(c(0,0,-6,-6),&quot;mm&quot;))

plotFigureQQ &lt;- function(dt, dataset, withInlet=TRUE, range=c(0.5, 3.5, 17, 37)){
    sdt &lt;- dt[, .(nle=neglog10expectedPvalue, nlo=neglog10observedPvalue, Method=Method, nllow=nllower, nlup=nlupper)]
    ggp &lt;- ggplot(sdt, aes(nle, nlo, col=Method)) + 
        geom_point(size=0.8) + 
        scale_color_brewer(palette=&#39;Dark2&#39;) + 
        geom_abline(intercept = 0, slope = 1) + 
        labs(title = paste(dataset),  
             x=expression(paste(-log[10], &quot; (expected &quot;, italic(P), &quot;-value)&quot;)),
             y=expression(paste(-log[10], &quot; (obs. &quot;, italic(P), &quot;-value)&quot;))) + 
        geom_ribbon(data=sdt[Method==&#39;PROTRIDER&#39;], col=alpha(&#39;gray&#39;, 0.2), fill=alpha(&#39;gray&#39;, 0.5),
                    aes(x=nle, ymin = nllow, ymax = nlup))
    
    if(isTRUE(withInlet)){
        ggZoom &lt;- ggplotGrob(
            ggp + coord_cartesian(xlim=c(2, 3.5), ylim=c(2, 7)) + zoomtheme)
        ggp &lt;- ggp + annotation_custom(grob=ggZoom, xmin=range[1], xmax=range[2],
                                       ymin=range[3], ymax=range[4])
    }
    ggp
}

# global qq plot for PROTRIDER
plotdt &lt;- getQQPlottingData(protrider_pval_list, method_name=&#39;PROTRIDER&#39;)
ggQQ &lt;- plotFigureQQ(plotdt, &#39;Global QQ-plot for PROTRIDER&#39;, withInlet=FALSE)
ggQQ</code></pre>
<p><img src="Scripts_Supplementary_figures_S_Fig5_files/figure-html/unnamed-chunk-1-4.png" width="672" /></p>
<pre class="r"><code># global qq plot for both PROTRIDER and limma
plotdt_limma &lt;- getQQPlottingData(limma_pval_list, method_name=&#39;limma-based approach&#39;)
plotdt_both &lt;- rbind(plotdt, plotdt_limma)
ggQQ_both &lt;- plotFigureQQ(plotdt_both, &#39;Global QQ-plot&#39;, withInlet=FALSE)
ggQQ_both</code></pre>
<p><img src="Scripts_Supplementary_figures_S_Fig5_files/figure-html/unnamed-chunk-1-5.png" width="672" /></p>

<div id="rmd-source-code">IyctLS0KIycgdGl0bGU6IFBST1RSSURFUiBjb21wYXJpc29uIHRvIGxpbW1hLWJhc2VkIGFwcHJvYWNoICAgCiMnIGF1dGhvcjogc2NoZWxsZXIsIGxvaXBmaW5nZXIKIycgd2I6CiMnICBpbnB1dDoKIycgIC0gcHJvdHJpZGVyX3Jlc3VsdHM6ICdgc20gY29uZmlnWyJQUk9DX0RBVEEiXSArICIvcHJvdHJpZGVyL1BST1RSSURFUl9yZXN1bHRzLnJkcyJgJwojJyAgLSBsaW1tYV9yZXN1bHRzOiAnYHNtIGNvbmZpZ1siUFJPQ19EQVRBIl0gKyAiL2xpbW1hL0xJTU1BX3Jlc3VsdHMucmRzImAnCiMnICAtIHNhbXBsZV9hbm5vdGF0aW9uOiAnYHNtIGNvbmZpZ1siQU5OT1RBVElPTiJdYCcKIycgIG91dHB1dDoKIycgIC0gZmlnOiAnYHNtIGNvbmZpZ1siRklHVVJFX0RJUiJdICsgIi9TdXBwbGVtZW50YXJ5X2ZpZ3VyZXMvU19GaWc1LnBkZiJgJwojJyBvdXRwdXQ6IAojJyAgIGh0bWxfZG9jdW1lbnQ6CiMnICAgIGNvZGVfZm9sZGluZzogaGlkZQojJyAgICBjb2RlX2Rvd25sb2FkOiBUUlVFCiMnLS0tCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIyMgcGxvdCBsaW1tYSAtIHByb3RyaWRlciBiZW5jaG1hcmsKCmxpYnJhcnkocGx5cikKbGlicmFyeShkcGx5cikKbGlicmFyeShkYXRhLnRhYmxlKQpsaWJyYXJ5KGdncGxvdDIpCmxpYnJhcnkoZ2dwdWJyKQoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKIyMjIHJlYWQgaW4gcHJvdHJpZGVyIHJlc3VsdHMKcHJvdHJpZGVyX2ZpbGVuYW1lIDwtIHNuYWtlbWFrZUBpbnB1dCRwcm90cmlkZXJfcmVzdWx0cwpwcm90cmlkZXJfcHZhbF9saXN0IDwtIGFzLmRhdGEudGFibGUocmVhZFJEUyhwcm90cmlkZXJfZmlsZW5hbWUpKQpwcm90cmlkZXJfcHZhbF9saXN0JHNhbXBsZV9wcm90ID0gcGFzdGUwKHByb3RyaWRlcl9wdmFsX2xpc3QkU0FNUExFX0lELCJfIiwgcHJvdHJpZGVyX3B2YWxfbGlzdCRnZW5lSUQpCgojIyMgcmVhZCBpbiBsaW1tYSByZXN1bHRzCmxpbW1hX2ZpbGVuYW1lIDwtIHNuYWtlbWFrZUBpbnB1dCRsaW1tYV9yZXN1bHRzCmxpbW1hX3B2YWxfbGlzdCA8LSBhcy5kYXRhLnRhYmxlKHJlYWRSRFMobGltbWFfZmlsZW5hbWUpKQpsaW1tYV9wdmFsX2xpc3Qkc2FtcGxlX3Byb3QgPSBwYXN0ZTAobGltbWFfcHZhbF9saXN0JFNBTVBMRV9JRCwiXyIsbGltbWFfcHZhbF9saXN0JGdlbmVJRCkKCiMjIyBrZWVwIG9ubHkgc2FtcGxlcyBpbiBib3RoIGFuYWx5c2VzLCBvbmx5IGlmIGFsbCB3aG9sZSBsaW1tYSBsaXN0IGlzIGNvbnNpZGVyZWQKb25seV9pZGVudGljYWxfc2FtcGxlcyA8LSBpbnRlcnNlY3QobGltbWFfcHZhbF9saXN0JHNhbXBsZV9wcm90LCBwcm90cmlkZXJfcHZhbF9saXN0JHNhbXBsZV9wcm90KQpwdmFsX2FlX3ByZSA8LSBzdWJzZXQocHJvdHJpZGVyX3B2YWxfbGlzdCwgc2FtcGxlX3Byb3QgJWluJSBvbmx5X2lkZW50aWNhbF9zYW1wbGVzKQpwdmFsX2xpbW1hX3ByZSA8LSBzdWJzZXQobGltbWFfcHZhbF9saXN0LCBzYW1wbGVfcHJvdCAlaW4lIG9ubHlfaWRlbnRpY2FsX3NhbXBsZXMpCgoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKIyMjIGdldCBzYW1wbGUgYW5ub3RhdGlvbgpzYV9wcm90IDwtIGZyZWFkKHNuYWtlbWFrZUBpbnB1dCRzYW1wbGVfYW5ub3RhdGlvbikKc2FfcHJvdCA8LSBzYV9wcm90W1VTRV9GT1JfUFJPVEVPTUlDU19QQVBFUiA9PSBUXQpzYV9wcm90JEtOT1dOX01VVEFUSU9OIDwtIHRvdXBwZXIoc2FfcHJvdCRLTk9XTl9NVVRBVElPTikKZXRwX20gPC0gc2FfcHJvdFssIGMoJ1NBTVBMRV9JRCcsICdLTk9XTl9NVVRBVElPTicsJ0NBVEVHT1JZJyldCgojIHNhID0gc3Vic2V0KGV0cF9tLCBDQVRFR09SWT09IkkiKVssMToyXSAgICMjIyBmb3Igb25seSBjb25maXJtZWQgb25lcwojIHNhID0gc3Vic2V0KGV0cF9tLCBDQVRFR09SWSAlaW4lIGMoIkkiLCAiSUlhIiwgIklJSSIpKVssMToyXSAgICMjIyBmb3Igb25seSBjb25maXJtZWQgb25lcwpzYSA9IHN1YnNldChldHBfbSwgQ0FURUdPUlkgJWluJSBjKCJJIiwgIklJYSIpKVssMToyXSAjIyMgb25seSBjYXNlcyB3aXRoIHByZXZpb3VzIGNhbmRpZGF0ZQpzYSRjb25maXJtZWRfb3V0ID0gIWlzLm5hKHNhJEtOT1dOX01VVEFUSU9OKQpzYSRzYW1wbGVfcHJvdCA9IHBhc3RlMChzYSRTQU1QTEVfSUQsIl8iLHNhJEtOT1dOX01VVEFUSU9OKQoKIyMjIG1lcmdlIGtub3duIG11dGF0aW9uIHRvIHJlc3VsdCBsaXN0cwpwdmFsX2FlX3NvbHZlZCA9IGpvaW4ocHZhbF9hZV9wcmUsc2EpCnB2YWxfYWVfc29sdmVkW2lzLm5hKGNvbmZpcm1lZF9vdXQpLCBjb25maXJtZWRfb3V0Oj1GQUxTRV0KcHZhbF9hZV9zb2x2ZWQgPSBwdmFsX2FlX3NvbHZlZFtvcmRlcihwdmFsX2FlX3NvbHZlZCRQUk9URUlOX1BWQUxVRSksXQpwdmFsX2FlX3NvbHZlZFssIG51bV9vdXRfY2FsbGVkOj1jdW1zdW0oY29uZmlybWVkX291dCldCgpwdmFsX2xpbW1hX3NvbHZlZCA9IGpvaW4ocHZhbF9saW1tYV9wcmUsc2EpCnB2YWxfbGltbWFfc29sdmVkJGNvbmZpcm1lZF9vdXRbaXMubmEocHZhbF9saW1tYV9zb2x2ZWQkY29uZmlybWVkX291dCldID0gRkFMU0UKcHZhbF9saW1tYV9zb2x2ZWQgPSBwdmFsX2xpbW1hX3NvbHZlZFtvcmRlcihwdmFsX2xpbW1hX3NvbHZlZCRQUk9URUlOX1BWQUxVRSksXQpwdmFsX2xpbW1hX3NvbHZlZCRudW1fb3V0X2NhbGxlZCA9IGN1bXN1bShwdmFsX2xpbW1hX3NvbHZlZCRjb25maXJtZWRfb3V0KQoKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMjIyBwbG90dGluZwpwYWRqX2N1dG9mZiA9IDAuMSAjMC4wNSAKYWVfcGxvdCA9IHN1YnNldChwdmFsX2FlX3NvbHZlZCwgUFJPVEVJTl9QQURKIDw9IHBhZGpfY3V0b2ZmKQphZV9wbG90JHB2YWx1ZSA9IGxvZzEwKGFlX3Bsb3QkUFJPVEVJTl9QVkFMVUUpCmxpbW1hX3Bsb3QgPSBzdWJzZXQocHZhbF9saW1tYV9zb2x2ZWQsIFBST1RFSU5fUEFESiA8PSBwYWRqX2N1dG9mZikKbGltbWFfcGxvdCRwdmFsdWUgPSBsb2cxMChsaW1tYV9wbG90JFBST1RFSU5fUFZBTFVFKQoKIyAjIFJlY2FsbCBwbG90IGZyb20gU3RlZmFuIEwuCiMgcGxvdCgxOm5yb3coYWVfcGxvdCksYWVfcGxvdCRudW1fb3V0X2NhbGxlZCwgJ2wnLCAgbHdkPTIsCiMgICAgICBjb2w9J29yYW5nZScsIHhsaW09YygwLG5yb3cobGltbWFfcGxvdCkpLAojICAgICAgeWxpbT1jKDAsbWF4KG1heChhZV9wbG90JG51bV9vdXRfY2FsbGVkKSwgbWF4KGxpbW1hX3Bsb3QkbnVtX291dF9jYWxsZWQpKSArMiksCiMgICAgICB5bGFiPSdyZWNhbGwgKCNkZXRlY3RlZCBjb25maXJtZWQgY2FzZXMpJywgeGxhYj0icCB2YWx1ZSByYW5rIiwgbWFpbj1wYXN0ZTAoJ2Fkal9wdmFsOiAnLHBhZGpfY3V0b2ZmLCcgb3V0bGllciBjYWxsZWQnKSApCiMgbGluZXMoMTpucm93KGxpbW1hX3Bsb3QpLGxpbW1hX3Bsb3QkbnVtX291dF9jYWxsZWQsIGNvbD0nYmx1ZScsIGx3ZD0yKQojIGxlZ2VuZCgnYm90dG9tcmlnaHQnLAojICAgICAgICBsZWdlbmQ9YyhwYXN0ZTAoJ1BST1RSSURFUiBbJyxtYXgoYWVfcGxvdCRudW1fb3V0X2NhbGxlZCksICcgaW4gJyx3aGljaC5tYXgoYWVfcGxvdCRudW1fb3V0X2NhbGxlZCksJyAvICcgLG5yb3coYWVfcGxvdCksJ10nKSAsCiMgICAgICAgICAgICAgICAgIHBhc3RlMCgnbGltbWEgWycsbWF4KGxpbW1hX3Bsb3QkbnVtX291dF9jYWxsZWQpLCAnIGluICcsd2hpY2gubWF4KGxpbW1hX3Bsb3QkbnVtX291dF9jYWxsZWQpLCcgLyAnICxucm93KGxpbW1hX3Bsb3QpLCddJykgKSwKIyAgICAgICAgY29sPWMoJ29yYW5nZScsJ2JsdWUnKSwgbHR5PTEsIGx3ZD0xMCwgdGl0bGU9Im1ldGhvZCBbY29uZmlybWVkIGNhc2VzXSIpCgojIyMgc2FtZSBwbG90IGJ1dCBhcyBnZ3Bsb3QKYWVfcGxvdFssIHJhbms6PWZyYW5rKFBST1RFSU5fUFZBTFVFLCB0aWVzLm1ldGhvZD0ibWluIildCmFlX3Bsb3RbLCB0b3RhbDo9Lk5dCmFlX3Bsb3RbLCBtZXRob2Q6PSJQUk9UUklERVIiXQpsaW1tYV9wbG90WywgcmFuazo9ZnJhbmsoUFJPVEVJTl9QVkFMVUUsIHRpZXMubWV0aG9kPSJtaW4iKV0KbGltbWFfcGxvdFssIHRvdGFsOj0uTl0KbGltbWFfcGxvdFssIG1ldGhvZDo9ImxpbW1hLWJhc2VkIGFwcHJvYWNoIl0KCmFlX2xpbW1hX3Bsb3QgPC0gcmJpbmQoYWVfcGxvdFssLihwdmFsdWUsIG51bV9vdXRfY2FsbGVkLCByYW5rLCB0b3RhbCwgbWV0aG9kKV0sIAogICAgICAgICAgICAgICAgICAgICAgIGxpbW1hX3Bsb3RbLC4ocHZhbHVlLCBudW1fb3V0X2NhbGxlZCwgcmFuaywgdG90YWwsIG1ldGhvZCldKQpnIDwtIGdncGxvdChhZV9saW1tYV9wbG90LCBhZXMoeD1yYW5rLCB5PW51bV9vdXRfY2FsbGVkLCBjb2w9bWV0aG9kKSkgKwogICAgZ2VvbV9saW5lKCkgKwogICAgc2NhbGVfeV9jb250aW51b3VzKGxpbWl0cz1jKDAsIG5yb3coc2EpKSwgYnJlYWtzPXNlcSgwLCBucm93KHNhKSwgYnk9MTApLAogICAgICAgICAgICAgICAgICAgICAgIG1pbm9yX2JyZWFrcz1zZXEoMCwgbnJvdyhzYSktNSwgYnk9MTApKzUpICsKICAgIHhsYWIoInAgdmFsdWUgcmFuayIpICsgeWxhYigicmVjYWxsICgjZGV0ZWN0ZWQgY29uZmlybWVkIGNhc2VzKSIpICsgCiAgICBnZ3RpdGxlKHBhc3RlMCgiYWRqX3B2YWwgPD0gIiwgcGFkal9jdXRvZmYpKSArCiAgICB0aGVtZV9idygpICsKICAgIHRoZW1lKHRleHQ9ZWxlbWVudF90ZXh0KHNpemU9MTQpLCB0aXRsZT1lbGVtZW50X3RleHQoc2l6ZT0xNCksCiAgICAgICAgICBsZWdlbmQudGl0bGU9ZWxlbWVudF9ibGFuaygpLCBsZWdlbmQucG9zaXRpb249ImJvdHRvbSIsICAjIGMoMC44LCAwLjE1KQogICAgICAgICAgcGxvdC50aXRsZSA9IGVsZW1lbnRfdGV4dChoanVzdCA9IDAuNSksIGxlZ2VuZC50ZXh0PWVsZW1lbnRfdGV4dChzaXplPTE0KSkKIyBnCgojIyMjIHByZWNpc2lvbiByZWNhbGwgcGxvdAphZV9wbG90WywgYDo9YChwcmVjaXNpb249bnVtX291dF9jYWxsZWQvcmFuaywgcmVjYWxsPW51bV9vdXRfY2FsbGVkL25yb3coc2EpKV0KbGltbWFfcGxvdFssIGA6PWAocHJlY2lzaW9uPW51bV9vdXRfY2FsbGVkL3JhbmssIHJlY2FsbD1udW1fb3V0X2NhbGxlZC9ucm93KHNhKSldCgpwbG90X2R0IDwtIHJiaW5kKGFlX3Bsb3RbLC4ocHJlY2lzaW9uLCByZWNhbGwsIG1ldGhvZCldLCBsaW1tYV9wbG90WywuKHByZWNpc2lvbiwgcmVjYWxsLCBtZXRob2QpXSkKCgpnX3ByIDwtIGdncGxvdChwbG90X2R0LCBhZXMoeD1yZWNhbGwsIHk9cHJlY2lzaW9uLCBjb2w9bWV0aG9kKSkgKyBnZW9tX2xpbmUoKSArIAogICAgc2NhbGVfeF9jb250aW51b3VzKGxpbWl0cz1jKDAsMSkpICsgc2NhbGVfeV9jb250aW51b3VzKGxpbWl0cz1jKDAsMC41NSkpICsKICAgIHRoZW1lX2J3KCkgKwogICAgdGhlbWUodGV4dD1lbGVtZW50X3RleHQoc2l6ZT0xNCksIHRpdGxlPWVsZW1lbnRfdGV4dChzaXplPTE0KSwKICAgICAgICAgIGxlZ2VuZC5wb3NpdGlvbj1jKDAuOCwgMC44NSkpCiMgZ19wcgoKCiMjIyBub21pbmFsIHAgdmFsdWUgY3V0b2ZmCnB2YWxfY3V0b2ZmID0gMC4wNSMwLjEjMC4wNSAjMC4wNSAjMSAjMC41IzEjIDAuMDUKYWVfcGxvdCA9IHN1YnNldChwdmFsX2FlX3NvbHZlZCwgUFJPVEVJTl9QVkFMVUUgPD0gcHZhbF9jdXRvZmYpCmFlX3Bsb3QkcHZhbHVlID0gbG9nMTAoYWVfcGxvdCRQUk9URUlOX1BWQUxVRSkKbGltbWFfcGxvdCA9IHN1YnNldChwdmFsX2xpbW1hX3NvbHZlZCwgUFJPVEVJTl9QVkFMVUUgPD0gcHZhbF9jdXRvZmYpCmxpbW1hX3Bsb3QkcHZhbHVlID0gbG9nMTAobGltbWFfcGxvdCRQUk9URUlOX1BWQUxVRSkKCmFlX3Bsb3RbLCByYW5rOj1mcmFuayhQUk9URUlOX1BWQUxVRSwgdGllcy5tZXRob2Q9Im1pbiIpXQphZV9wbG90WywgdG90YWw6PS5OXQphZV9wbG90WywgbWV0aG9kOj0iUFJPVFJJREVSIl0KbGltbWFfcGxvdFssIHJhbms6PWZyYW5rKFBST1RFSU5fUFZBTFVFLCB0aWVzLm1ldGhvZD0ibWluIildCmxpbW1hX3Bsb3RbLCB0b3RhbDo9Lk5dCmxpbW1hX3Bsb3RbLCBtZXRob2Q6PSJsaW1tYS1iYXNlZCBhcHByb2FjaCJdCgphZV9saW1tYV9wbG90IDwtIHJiaW5kKGFlX3Bsb3RbLC4ocHZhbHVlLCBudW1fb3V0X2NhbGxlZCwgcmFuaywgdG90YWwsIG1ldGhvZCldLCAKICAgICAgICAgICAgICAgICAgICAgICBsaW1tYV9wbG90WywuKHB2YWx1ZSwgbnVtX291dF9jYWxsZWQsIHJhbmssIHRvdGFsLCBtZXRob2QpXSkKZ19ub21pbmFsIDwtIGdncGxvdChhZV9saW1tYV9wbG90LCBhZXMoeD1yYW5rLCB5PW51bV9vdXRfY2FsbGVkLCBjb2w9bWV0aG9kKSkgKwogICAgZ2VvbV9saW5lKCkgKwogICAgc2NhbGVfeV9jb250aW51b3VzKGxpbWl0cz1jKDAsIG5yb3coc2EpKSwgYnJlYWtzPXNlcSgwLCBucm93KHNhKSwgYnk9MTApLAogICAgICAgICAgICAgICAgICAgICAgIG1pbm9yX2JyZWFrcz1zZXEoMCwgbnJvdyhzYSktNSwgYnk9MTApKzUpICsKICAgIHhsYWIoInAgdmFsdWUgcmFuayIpICsgeWxhYigicmVjYWxsICgjZGV0ZWN0ZWQgY29uZmlybWVkIGNhc2VzKSIpICsgCiAgICBnZ3RpdGxlKHBhc3RlMCgibm9taW5hbCBwdmFsdWUgPD0gIiwgcHZhbF9jdXRvZmYpKSArCiAgICB0aGVtZV9idygpICsKICAgIHRoZW1lKHRleHQ9ZWxlbWVudF90ZXh0KHNpemU9MTQpLCB0aXRsZT1lbGVtZW50X3RleHQoc2l6ZT0xNCksIAogICAgICAgICAgbGVnZW5kLnRpdGxlPWVsZW1lbnRfYmxhbmsoKSwgbGVnZW5kLnBvc2l0aW9uPSJib3R0b20iLAogICAgICAgICAgcGxvdC50aXRsZT1lbGVtZW50X3RleHQoaGp1c3QgPSAwLjUpLCBsZWdlbmQudGV4dD1lbGVtZW50X3RleHQoc2l6ZT0xNCkpCiMgZ19ub21pbmFsCgojIyMgY29tYmluZSBpbnRvIG9uZSBGaWd1cmU6IHBhbmVsIGEpIHJlY2FsbCBmb3IgcHZhbHMgd2l0aCBwYWRqIDwgMC4xOyBwYW5lbCBiKSByZWNhbGwgZm9yIGFsbCBub21pbmFsIHB2YWwgPCAwLjA1CmdfZmlnIDwtIGdnYXJyYW5nZShnLCBnX25vbWluYWwsIG5jb2w9MiwgY29tbW9uLmxlZ2VuZD1UUlVFLCBsZWdlbmQ9ImJvdHRvbSIsIGxhYmVscz1sZXR0ZXJzWzE6Ml0pCmNvbW1vbl90aXRsZSA8LSBwYXN0ZTAoIlJlY2FsbCBvZiBjYXNlcyB3aXRoIHBhdGhvZ2VuaWMgdmFyaWFudHMgYW5kIHZhbGlkYXRlZCBWVVMgKG49IiwgbnJvdyhzYSksICIpIikKZ19maWcgPC0gYW5ub3RhdGVfZmlndXJlKGdfZmlnLCB0b3AgPSB0ZXh0X2dyb2IoY29tbW9uX3RpdGxlLCBmYWNlID0gImJvbGQiLCBzaXplID0gMTYpKQpnX2ZpZwoKZmlndXJlX2ZpbGUgPC0gc25ha2VtYWtlQG91dHB1dCRmaWcKZ2dzYXZlKGZpZ3VyZV9maWxlLCBnX2ZpZywgd2lkdGg9MTUsIGhlaWdodD01KQojIHNhdmVSRFMobGlzdCgiZ19wYWRqIj1nLCAiZ19ub21pbmFsIj1nX25vbWluYWwpLCBmaWxlLnBhdGgoZGlybmFtZShmaWd1cmVfZmlsZSksICJwcm90cmlkZXJfbGltbWFfZmlnUzUucmRzIikpCgoKCiMjIyMgcHJlY2lzaW9uIHJlY2FsbCBwbG90IChub21pbmFsIHB2YWx1ZSBjdXRvZmYpCmFlX3Bsb3RbLCBgOj1gKHByZWNpc2lvbj1udW1fb3V0X2NhbGxlZC9yYW5rLCByZWNhbGw9bnVtX291dF9jYWxsZWQvbnJvdyhzYSkpXQpsaW1tYV9wbG90WywgYDo9YChwcmVjaXNpb249bnVtX291dF9jYWxsZWQvcmFuaywgcmVjYWxsPW51bV9vdXRfY2FsbGVkL25yb3coc2EpKV0KCnBsb3RfZHQgPC0gcmJpbmQoYWVfcGxvdFssLihwcmVjaXNpb24sIHJlY2FsbCwgbWV0aG9kKV0sIGxpbW1hX3Bsb3RbLC4ocHJlY2lzaW9uLCByZWNhbGwsIG1ldGhvZCldKQoKCmdfcHJfbm9tIDwtIGdncGxvdChwbG90X2R0LCBhZXMoeD1yZWNhbGwsIHk9cHJlY2lzaW9uLCBjb2w9bWV0aG9kKSkgKyBnZW9tX2xpbmUoKSArIAogICAgc2NhbGVfeF9jb250aW51b3VzKGxpbWl0cz1jKDAsMSkpICsgc2NhbGVfeV9jb250aW51b3VzKGxpbWl0cz1jKDAsMC41NSkpICsKICAgIHRoZW1lX2J3KCkgKwogICAgdGhlbWUodGV4dD1lbGVtZW50X3RleHQoc2l6ZT0xNCksIHRpdGxlPWVsZW1lbnRfdGV4dChzaXplPTE0KSwgCiAgICAgICAgICBsZWdlbmQudGl0bGU9ZWxlbWVudF9ibGFuaygpLCBsZWdlbmQucG9zaXRpb249ImJvdHRvbSIsCiAgICAgICAgICBwbG90LnRpdGxlPWVsZW1lbnRfdGV4dChoanVzdCA9IDAuNSksIGxlZ2VuZC50ZXh0PWVsZW1lbnRfdGV4dChzaXplPTE0KSkKIyBnX3ByX25vbQoKIyBUT0RPIG9ubHkgb25lIHBsb3QgbmVlZGVkLCBhZGQgdGhlIGRpZmZlcmVudCBwdmFsdWUgY3V0b2ZmcyBhcyBzaGFwZXMKZ19wcl9maWcgPC0gZ2dhcnJhbmdlKGdfcHIsIGdfcHJfbm9tLCBuY29sPTIsIGNvbW1vbi5sZWdlbmQ9VFJVRSwgbGVnZW5kPSJib3R0b20iLCBsYWJlbHM9bGV0dGVyc1sxOjJdKQpwcl9jb21tb25fdGl0bGUgPC0gcGFzdGUwKCJQcmVjaXNpb24tcmVjYWxsIGN1cnZlIGZvciBjYXNlcyB3aXRoIHBhdGhvZ2VuaWMgdmFyaWFudHMgYW5kIHZhbGlkYXRlZCBWVVMgKG49IiwgbnJvdyhzYSksICIpIikKZ19wcl9maWcgPC0gYW5ub3RhdGVfZmlndXJlKGdfcHJfZmlnLCB0b3AgPSB0ZXh0X2dyb2IocHJfY29tbW9uX3RpdGxlLCBmYWNlID0gImJvbGQiLCBzaXplID0gMTYpKQpnX3ByX2ZpZwoKCiMjIyMgcGxvdCB3aXRoIGJvdGggcHZhbHVlIGFuZCB6LXNjb3JlIGN1dG9mZnMKcHZhbF9jdXRvZmYgPC0gMC4wNSAKenNjb3JlX2N1dG9mZiA8LSAgMgphZV9wbG90X3B2YWwgPC0gc3Vic2V0KHB2YWxfYWVfc29sdmVkLCBQUk9URUlOX1BWQUxVRSA8PSBwdmFsX2N1dG9mZikKYWVfcGxvdF9wdmFsJHNjb3JlIDwtIGxvZzEwKGFlX3Bsb3RfcHZhbCRQUk9URUlOX1BWQUxVRSkKYWVfcGxvdF9wdmFsWyxtZXRob2Q6PSJQUk9UUklERVIiXQphZV9wbG90X3B2YWxbLHJhbmtlZEJ5Oj0icCB2YWx1ZSJdCmFlX3Bsb3RfeiA8LSBzdWJzZXQocHZhbF9hZV9zb2x2ZWQsIGFicyhQUk9URUlOX1pTQ09SRSkgPj0genNjb3JlX2N1dG9mZikKYWVfcGxvdF96JHNjb3JlIDwtIC1hYnMoYWVfcGxvdF96JFBST1RFSU5fWlNDT1JFKQphZV9wbG90X3ogPSBhZV9wbG90X3pbb3JkZXIoLWFicyhhZV9wbG90X3okUFJPVEVJTl9aU0NPUkUpKSxdCmFlX3Bsb3RfelssIG51bV9vdXRfY2FsbGVkOj1jdW1zdW0oY29uZmlybWVkX291dCldCmFlX3Bsb3RfelssbWV0aG9kOj0iUFJPVFJJREVSIl0KYWVfcGxvdF96WyxyYW5rZWRCeTo9Inx6IHNjb3JlfCJdCmxpbW1hX3Bsb3RfcHZhbCA8LSBzdWJzZXQocHZhbF9saW1tYV9zb2x2ZWQsIFBST1RFSU5fUFZBTFVFIDw9IHB2YWxfY3V0b2ZmKQpsaW1tYV9wbG90X3B2YWwkc2NvcmUgPC0gbG9nMTAobGltbWFfcGxvdF9wdmFsJFBST1RFSU5fUFZBTFVFKQpsaW1tYV9wbG90X3B2YWxbLG1ldGhvZDo9ImxpbW1hLWJhc2VkIGFwcHJvYWNoIl0KbGltbWFfcGxvdF9wdmFsWyxyYW5rZWRCeTo9InAgdmFsdWUiXQpsaW1tYV9wbG90X3ogPC0gc3Vic2V0KHB2YWxfbGltbWFfc29sdmVkLCBhYnMoUFJPVEVJTl9aU0NPUkUpID49IHpzY29yZV9jdXRvZmYpCmxpbW1hX3Bsb3RfeiRzY29yZSA8LSAtYWJzKGxpbW1hX3Bsb3RfeiRQUk9URUlOX1pTQ09SRSkKbGltbWFfcGxvdF96ID0gbGltbWFfcGxvdF96W29yZGVyKC1hYnMobGltbWFfcGxvdF96JFBST1RFSU5fWlNDT1JFKSksXQpsaW1tYV9wbG90X3pbLCBudW1fb3V0X2NhbGxlZDo9Y3Vtc3VtKGNvbmZpcm1lZF9vdXQpXQpsaW1tYV9wbG90X3pbLG1ldGhvZDo9ImxpbW1hLWJhc2VkIGFwcHJvYWNoIl0KbGltbWFfcGxvdF96WyxyYW5rZWRCeTo9Inx6IHNjb3JlfCJdCgpwbG90X2R0IDwtIHJiaW5kKGFlX3Bsb3RfcHZhbFssLihzY29yZSwgbnVtX291dF9jYWxsZWQsIG1ldGhvZCwgcmFua2VkQnkpXSwgCiAgICAgICAgICAgICAgICAgYWVfcGxvdF96WywuKHNjb3JlLCBudW1fb3V0X2NhbGxlZCwgbWV0aG9kLCByYW5rZWRCeSldLCAKICAgICAgICAgICAgICAgICBsaW1tYV9wbG90X3B2YWxbLC4oc2NvcmUsIG51bV9vdXRfY2FsbGVkLCBtZXRob2QsIHJhbmtlZEJ5KV0sIAogICAgICAgICAgICAgICAgIGxpbW1hX3Bsb3RfelssLihzY29yZSwgbnVtX291dF9jYWxsZWQsIG1ldGhvZCwgcmFua2VkQnkpXSkKCnBsb3RfZHRbLCByYW5rOj1mcmFuayhzY29yZSwgdGllcy5tZXRob2Q9Im1pbiIpLCBieT0ibWV0aG9kLHJhbmtlZEJ5Il0KcGxvdF9kdFssIHRvdGFsOj0uTiwgYnk9Im1ldGhvZCxyYW5rZWRCeSJdCnBsb3RfZHQKCnBsb3RfZHRbLHJhbmtlZEJ5Oj1mYWN0b3IocmFua2VkQnksIGxldmVscz1jKCJwIHZhbHVlIiwgInx6IHNjb3JlfCIpKV0KCiMgYWRkaXRpb25hbCBmaWc6IHJlY2FsbCBmb3IgYWxsIG5vbWluYWwgcHZhbCA8IDAuMDUgKyB8ei1zY29yZXwgPiAyCmxvZyA8LSBGQUxTRQojIGxvZyA8LSBUUlVFCmdfeiA8LSBnZ3Bsb3QocGxvdF9kdCwgYWVzKHg9cmFuaywgeT1udW1fb3V0X2NhbGxlZCwgY29sPW1ldGhvZCwgbGluZXR5cGU9cmFua2VkQnkpKSArCiAgICBnZW9tX2xpbmUoKSArCiAgICBzY2FsZV95X2NvbnRpbnVvdXMobGltaXRzPWMoMCwgbnJvdyhzYSkpLCBicmVha3M9c2VxKDAsIG5yb3coc2EpLCBieT0xMCksCiAgICAgICAgICAgICAgICAgICAgICAgbWlub3JfYnJlYWtzPXNlcSgwLCBucm93KHNhKS01LCBieT0xMCkrNSkgKwogICAgeGxhYigicmFuayIpICsgeWxhYigicmVjYWxsICgjZGV0ZWN0ZWQgY29uZmlybWVkIGNhc2VzKSIpICsgCiAgICBnZ3RpdGxlKHBhc3RlMCgiUmVjYWxsIG9mIGNhc2VzIHdpdGggcGF0aG9nZW5pYyB2YXJpYW50cyBhbmQgdmFsaWRhdGVkIFZVUyAobj0iLCBucm93KHNhKSwgIikiKSkgKwogICAgdGhlbWVfYncoKSArCiAgICB0aGVtZSh0ZXh0PWVsZW1lbnRfdGV4dChzaXplPTE0KSwgdGl0bGU9ZWxlbWVudF90ZXh0KHNpemU9MTQpLCAKICAgICAgICAgIGxlZ2VuZC5wb3NpdGlvbj0iYm90dG9tIiwgbGVnZW5kLmJveD0iaG9yaXpvbnRhbCIsIGxlZ2VuZC5kaXJlY3Rpb249InZlcnRpY2FsIiwKICAgICAgICAgIHBsb3QudGl0bGU9ZWxlbWVudF90ZXh0KGhqdXN0ID0gMC41KSwgbGVnZW5kLnRleHQ9ZWxlbWVudF90ZXh0KHNpemU9MTQpKSArCiAgICBndWlkZXMoY29sb3IgPSBndWlkZV9sZWdlbmQodGl0bGUucG9zaXRpb249ImxlZnQiLCBvcmRlcj0xLCB0aXRsZS50aGVtZT1lbGVtZW50X2JsYW5rKCkpLAogICAgICAgICAgIGxpbmV0eXBlPWd1aWRlX2xlZ2VuZCgicmFua2VkIGJ5OiIsIHRpdGxlLnBvc2l0aW9uPSJsZWZ0Iiwgb3JkZXI9MikpCmlmKGxvZykgZ196IDwtIGdfeiArIHNjYWxlX3hfbG9nMTAoKQpnX3oKCgoKIyMjIyBQUk9UUklERVIgZ2xvYmFsIHFxLXBsb3QKIyBjb2RlIHNsaWdodGx5IGFkanVzdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2dhZ25ldXJsYWIvT1VUUklERVItYW5hbHlzaXMvYmxvYi9tYXN0ZXIvU2NyaXB0cy9QYXBlclBsb3RzL0ZpZ3VyZTNfZ2xvYmFsX3FxX3Jlcy5SIApnZXRRUVBsb3R0aW5nRGF0YSA8LSBmdW5jdGlvbihwdmFsX2xpc3QsIG1ldGhvZF9uYW1lLCBjb25mLmFscGhhPTAuMDUpewogICAgcXFQbG90RFQgPC0gZGF0YS50YWJsZShvYnNlcnZlZFB2YWx1ZT1wdmFsX2xpc3RbLFBST1RFSU5fUFZBTFVFXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJlcnJhbnQ9cHZhbF9saXN0WyxQUk9URUlOX291dGxpZXJdLAogICAgICAgICAgICAgICAgICAgICAgICAgICBNZXRob2Q9bWV0aG9kX25hbWUpCiAgICBxcVBsb3REVCA8LSBxcVBsb3REVFtvcmRlcihvYnNlcnZlZFB2YWx1ZSldCiAgICAKICAgIHFxUGxvdERUWyxleHBlY3RlZFB2YWx1ZTo9IHBwb2ludHMob2JzZXJ2ZWRQdmFsdWUpLCBieT1NZXRob2RdCiAgICAKICAgICMgc2V0IGNvbmZpZGVuY2UKICAgIHFxUGxvdERUWyxubHVwcGVyOj0tbG9nMTAocWJldGEoICBjb25mLmFscGhhLzIsIDE6Lk4sIC5OOjEpKSwgYnk9TWV0aG9kXQogICAgcXFQbG90RFRbLG5sbG93ZXI6PS1sb2cxMChxYmV0YSgxLWNvbmYuYWxwaGEvMiwgMTouTiwgLk46MSkpLCBieT1NZXRob2RdCiAgICAKICAgICMjIHNhbXBsZSB0byBhdm9pZCBwbG90dGluZyBwcm9ibGVtcy4KICAgIHFxUGxvdERUU2FtcGxlZCA8LSBxcVBsb3REVFsKICAgICAgICBvYnNlcnZlZFB2YWx1ZSA8ICAxRS0zIHwKICAgICAgICAgICAgb2JzZXJ2ZWRQdmFsdWUgPCAgMUUtMiAmIHNhbXBsZShjKFRSVUUsIEZBTFNFKSwgbnJvdyhxcVBsb3REVCksIHByb2IgPSBjKDAuMSwgIDAuOSksICByZXBsYWNlID0gVFJVRSl8CiAgICAgICAgICAgIG9ic2VydmVkUHZhbHVlID49IDFFLTIgJiBzYW1wbGUoYyhUUlVFLCBGQUxTRSksIG5yb3cocXFQbG90RFQpLCBwcm9iID0gYygwLjAxLCAwLjk5KSwgcmVwbGFjZSA9IFRSVUUpXQogICAgcXFQbG90RFRTYW1wbGVkWyxuZWdsb2cxMGV4cGVjdGVkUHZhbHVlIDo9IC1sb2cxMChleHBlY3RlZFB2YWx1ZSldCiAgICBxcVBsb3REVFNhbXBsZWRbLG5lZ2xvZzEwb2JzZXJ2ZWRQdmFsdWUgOj0gLWxvZzEwKG9ic2VydmVkUHZhbHVlKV0KICAgIAogICAgcmV0dXJuKHFxUGxvdERUU2FtcGxlZCkKfQoKem9vbXRoZW1lIDwtIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbj0ibm9uZSIsIGF4aXMudGl0bGUueD1lbGVtZW50X2JsYW5rKCksCiAgICAgICAgICAgICAgICAgICBheGlzLnRpdGxlLnk9ZWxlbWVudF9ibGFuaygpLCB0aXRsZSA9IGVsZW1lbnRfYmxhbmsoKSwKICAgICAgICAgICAgICAgICAgIHBhbmVsLmdyaWQubWFqb3IgPSBlbGVtZW50X2JsYW5rKCksIHBhbmVsLmdyaWQubWlub3IgPSBlbGVtZW50X2JsYW5rKCksIAogICAgICAgICAgICAgICAgICAgcGFuZWwuYmFja2dyb3VuZCA9IGVsZW1lbnRfcmVjdChjb2xvcj0nd2hpdGUnLCBmaWxsPSJ3aGl0ZSIpLAogICAgICAgICAgICAgICAgICAgcGxvdC5iYWNrZ3JvdW5kID0gZWxlbWVudF9yZWN0KGNvbG9yPSd3aGl0ZScsIGZpbGwgPSAid2hpdGUiKSwKICAgICAgICAgICAgICAgICAgIHBsb3QubWFyZ2luID0gdW5pdChjKDAsMCwtNiwtNiksIm1tIikpCgpwbG90RmlndXJlUVEgPC0gZnVuY3Rpb24oZHQsIGRhdGFzZXQsIHdpdGhJbmxldD1UUlVFLCByYW5nZT1jKDAuNSwgMy41LCAxNywgMzcpKXsKICAgIHNkdCA8LSBkdFssIC4obmxlPW5lZ2xvZzEwZXhwZWN0ZWRQdmFsdWUsIG5sbz1uZWdsb2cxMG9ic2VydmVkUHZhbHVlLCBNZXRob2Q9TWV0aG9kLCBubGxvdz1ubGxvd2VyLCBubHVwPW5sdXBwZXIpXQogICAgZ2dwIDwtIGdncGxvdChzZHQsIGFlcyhubGUsIG5sbywgY29sPU1ldGhvZCkpICsgCiAgICAgICAgZ2VvbV9wb2ludChzaXplPTAuOCkgKyAKICAgICAgICBzY2FsZV9jb2xvcl9icmV3ZXIocGFsZXR0ZT0nRGFyazInKSArIAogICAgICAgIGdlb21fYWJsaW5lKGludGVyY2VwdCA9IDAsIHNsb3BlID0gMSkgKyAKICAgICAgICBsYWJzKHRpdGxlID0gcGFzdGUoZGF0YXNldCksICAKICAgICAgICAgICAgIHg9ZXhwcmVzc2lvbihwYXN0ZSgtbG9nWzEwXSwgIiAoZXhwZWN0ZWQgIiwgaXRhbGljKFApLCAiLXZhbHVlKSIpKSwKICAgICAgICAgICAgIHk9ZXhwcmVzc2lvbihwYXN0ZSgtbG9nWzEwXSwgIiAob2JzLiAiLCBpdGFsaWMoUCksICItdmFsdWUpIikpKSArIAogICAgICAgIGdlb21fcmliYm9uKGRhdGE9c2R0W01ldGhvZD09J1BST1RSSURFUiddLCBjb2w9YWxwaGEoJ2dyYXknLCAwLjIpLCBmaWxsPWFscGhhKCdncmF5JywgMC41KSwKICAgICAgICAgICAgICAgICAgICBhZXMoeD1ubGUsIHltaW4gPSBubGxvdywgeW1heCA9IG5sdXApKQogICAgCiAgICBpZihpc1RSVUUod2l0aElubGV0KSl7CiAgICAgICAgZ2dab29tIDwtIGdncGxvdEdyb2IoCiAgICAgICAgICAgIGdncCArIGNvb3JkX2NhcnRlc2lhbih4bGltPWMoMiwgMy41KSwgeWxpbT1jKDIsIDcpKSArIHpvb210aGVtZSkKICAgICAgICBnZ3AgPC0gZ2dwICsgYW5ub3RhdGlvbl9jdXN0b20oZ3JvYj1nZ1pvb20sIHhtaW49cmFuZ2VbMV0sIHhtYXg9cmFuZ2VbMl0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHltaW49cmFuZ2VbM10sIHltYXg9cmFuZ2VbNF0pCiAgICB9CiAgICBnZ3AKfQoKIyBnbG9iYWwgcXEgcGxvdCBmb3IgUFJPVFJJREVSCnBsb3RkdCA8LSBnZXRRUVBsb3R0aW5nRGF0YShwcm90cmlkZXJfcHZhbF9saXN0LCBtZXRob2RfbmFtZT0nUFJPVFJJREVSJykKZ2dRUSA8LSBwbG90RmlndXJlUVEocGxvdGR0LCAnR2xvYmFsIFFRLXBsb3QgZm9yIFBST1RSSURFUicsIHdpdGhJbmxldD1GQUxTRSkKZ2dRUQoKIyBnbG9iYWwgcXEgcGxvdCBmb3IgYm90aCBQUk9UUklERVIgYW5kIGxpbW1hCnBsb3RkdF9saW1tYSA8LSBnZXRRUVBsb3R0aW5nRGF0YShsaW1tYV9wdmFsX2xpc3QsIG1ldGhvZF9uYW1lPSdsaW1tYS1iYXNlZCBhcHByb2FjaCcpCnBsb3RkdF9ib3RoIDwtIHJiaW5kKHBsb3RkdCwgcGxvdGR0X2xpbW1hKQpnZ1FRX2JvdGggPC0gcGxvdEZpZ3VyZVFRKHBsb3RkdF9ib3RoLCAnR2xvYmFsIFFRLXBsb3QnLCB3aXRoSW5sZXQ9RkFMU0UpCmdnUVFfYm90aAo=</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("S_Fig5.R");
  window.initializeCodeFolding("hide" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
